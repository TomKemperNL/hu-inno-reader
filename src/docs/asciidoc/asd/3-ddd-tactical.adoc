== Domain-Driven Design - Tactical

=== Inleiding

Domain-Driven Design (hierna afgekort DDD, want het is nogal een mondvol) is het geesteskind van Eric Evans cite:[evans_ddd], en zoals de naam suggereert, claimt dat de primaire drijfveer achter je software-design het domein zelf moet zijn. Primair is dus niet
of je code op een bepaalde manier gestructureerd is, of hoe performant het is, of dat de data allemaal netjes genormaliseerd is, maar puur of de code 'het domein' uitdrukt.

En nu komen we meteen op het grootste issue dat men heeft met DDD heeft: wat betekent het in vredesnaam allemaal? Klassiek gezien bestaat DDD uit twee delen, het tactische deel, en het strategische. Het strategische gedeelte wordt gezien als het meest belangrijke en vernieuwende, en gaat over hoe software ontwikkeling vaak verschillende conflicterende visies op "het domein" moet verenigen: dit zullen we behandelen in <<ddd-strategic>>. We starten met het tactische deel, het deel dat direct toepasbaar is binnen het ontwikkelen van een enkele applicatie.

Laten we eerst even kijken wat voor soort code we willen voorkomen:

[#updateBoeking]
[source, java]
.wijzigen van een boeking in Java
----
//In een service/applicatie-laag, vlak onder de presentatie/ui-laag
public Boeking updateBoeking(long boekingId, int aantalPersonen, double prijs, long klasse) {
    Optional<Boeking> gevondenBoeking = boekingRepository.findById(boekingId);
    Reisklasse reisKlasse = reisKlasseService.findById(klasse);
    if (gevondenBoeking.isPresent()) {
        Boeking boeking = gevondenBoeking.get();
        boeking.setAantalPersonen(aantalPersonen);
        boeking.setPrijs(prijs);
        boeking.setKlasse(reisKlasse);
        boeking.setStatus(BoekingStatus.active)
        return boekingRepository.save(boeking);
    }
    throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Er is geen boeking gevonden met boeking_id: " + boekingId);
}
----


Als we kijken naar <<updateBoeking>> dan zien we iets geks gebeuren: prijs, klasse en aantalpersonen kunnen los van elkaar ingevoerd worden. Dat is aan de ene kant heel flexibel, maar het is zeer waarschijnlijk dat in het domein van het boeken van kaartjes (in dit geval voor een vliegreis) dat de prijs iets te maken heeft met het aantal tickets en in welke klasse er gevlogen wordt...

Kortom, puur in de _signatuur_ (naam van de method, welke parameters er gevraagd worden, en wat er gereturned wordt) zie je al gekkigheid. We kunnen in deze methode eigenlijk geen nuttig werk verrichten, behalve domweg data doorschuiven. Aangezien deze methode in de service-laag woont betekent dat dat de echte bedrijfslogica omhoog gedrukt wordt de presentatielaag in, iets dat in elk geval de testbaarheid en herbruikbaarheid niet ten goede zal komen.

[#updateKlant]
[source, java]
.Updaten van een klant in Java
----
public Klant updateKlant(long id, 
        String voornaam, String achternaam, Integer leeftijd, String nationaliteit,
        String email, String telefoonNr,
        String straat, String huisNr, String toevoeging, String postcode, String stad, String land) throws KlantNotFoundException {
    Klant klant = klantRepository.findById(id).orElseThrow(() -> new KlantNotFoundException("klant met id " + id + " kan niet worden gevonden!"));
    Passagier passagierGegevens = klant.getPassagierGegevens();

    if (voornaam != null) passagierGegevens.setVoornaam(voornaam);
    if (achternaam != null) passagierGegevens.setAchternaam(achternaam);    
    //Etc... etc...
    if (stad != null) passagierGegevens.setStad(stad);
    if (land != null) passagierGegevens.setLand(land);

    return klantRepository.save(klant);
}
----

Als tweede voorbeeld zien we <<updateKlant>>. Het eerste dat opvalt is het grote aantal parameters van deze methode (en dat gaan er alleen maar meer worden), en het tweede is dat het bijna allemaal strings zijn. Het fijne aan Strings is dat ze heel flexibel zijn, en het lastige aan Strings is dat ze heel flexibel zijn. Het is makkelijk te vergeten omdat de variabelenamen onze gedachte sturen, maar een String in Java kan zowel leeg ("") zijn, als maximaal 2,147,483,647	karakters lang (ter vergelijking, alle Lord of the Rings boeken, inclusief de Hobbit zijn ong. 5 miljoen karakters), en er kan iets heel redelijks inzitten zoals "Ligusterlaan", of random nonsens zoals "$#I&YFKJDSDH#*$(#)". Kortom, die Strings, die zeggen ons niet zo gek veel. Ze zorgen er in elk geval niet voor dat onze code domein-gedreven voelt.

Belangrijker nog bij een method als updateKlant is dat we graag zouden willen kunnen inschatten of er bugs in zitten. Dat is bij deze method erg lastig! We hebben namelijk geen idee wat de context is waarin deze operatie gebeurd. Zou er misschien een verband zijn tussen de nationaliteit en het land? Geen idee! Kortom, de naam van de methode vertelt ons bizar weinig wat er in deze methode moet gebeurenfootnote:[Op _applicatie_-niveau. Als deze method in een data-access laag zou voorkomen is het niet zo'n hele gekke methode. Maar we gebruiken zelfs een repository, dus we zijn zeker geen data-access code, want dat zit waarschijnlijk achter die repository-variabele...]...

Tot slot zit er nog iets riskants in de manier waarop zowel updateKlant als updateBoeking als eerste argument een kale _long_ vragen. Dat betekent dat je als programmeur heel erg moet oppassen dat je niet per ongeluk het verkeerde id doorgeeft. Aangenomen dat de presentatielaag redelijke variabelenamen heeft zal dit risico wel meevallen. 

Maar als we dit idee van kale ids een klein beetje doortrekken kun je best in de problemen komen:
[source, java]
.cancelBooking
----
//In een class BookingService
public Booking cancelBooking(long flightID, long bookingID, long passengerId) throws MessagingException {
   // Implementatie is niet zo relevant
}

//Deze kan een niveau hoger worden aangeroepen als:

bookingService.cancelBooking(102387, 321314, 89427); //of misschien
bookingService.cancelBooking(102387, 89427, 321314); //of misschien
bookingService.cancelBooking(89427, 321314, 102387); //of nog wat andere mogelijkheden...

----
Toevallig zou een moderne java-IDE zoals IntelliJ je in deze gevallen de parameternamen in de methode laten zien, maar dat is vrij IDE & programmeertaal-specifiek. Het is een oplossing voor een probleem dat er eigenlijk niet zou moeten zijn.

=== Ubiquitous Language

[quote, 'https://twitter.com/secretGeek/status/7269997868[Leon Bambrick]']
"There are 2 hard problems in computer science: 
cache invalidation, naming things, and off-by-1 errors."

De eerste stap die DDD neemt om je code te verbeteren is niet eens zo heel technisch, maar wel moeilijk: naming things. Wat nou als we daar iets beter ons best op deden. We hebben het dan over namen van methods, variabelen, classes, packages, etc. etc. 

Een paar simpele gevallen zie je al in de voorbeelden hierboven. Meestal als een methode _setXYZ_ of _updateXYZ_ heet, of als een class een _XYZManager_ is, dan is het totaal niet duidelijk wanneer het uitvoeren van die method wel of niet zou mogen. Het is niet logisch om zomaar de _setLand_ method aan te roepen, los van _setStad_, die zaken hebben met elkaar te maken. Je kunt waarschijnlijk niet zomaar _booking.setStatus(BookingStatus.Active)_ aanroepen, daar zitten regels aan!

Feitelijk is dit niets anders dan het standaard Object-Oriented Programming-principe Encapsulatie. We willen onze objecten beschermen tegen wijzigingen die ze in een ongeldige toestand zouden plaatsen. 

Dus de eerste stap is om wat je toch al aan dingen hebt een goede naam te geven. Laten we voor het gemak aannemen dat al die velden bij _updateKlant_ op een enkel formulier op een standaard Profile-pagina. Dan is een redelijke naam voor die method _processProfileForm_.

De tweede stap is om meer dingen te maken die een naam kunnen hebben. In cite:[fowler_refactoring_2018] staan genoeg suggesties, zoals het introduceren van extra variabelen met https://refactoring.com/catalog/extractVariable.html[Extract Variable], het introduceren van korte beschrijvende methods met https://refactoring.com/catalog/extractFunction.html[Extract Method] of hele nieuwe objecten met https://refactoring.com/catalog/extractClass.html[Extract Class]. En dat brengt ons 'toevallig' bij Value Objects...

=== Value Objects

Een value-object is een object die een 'hele waarde' representeert. Kijk bijv. nog eens naar <<updateKlant>>. We sturen daar bijv. alle losse velden van een _Adres_ door. Netter is dan om één object van de class _Adres_ door te geven, dan los je ook gelijk het probleem op dat je bijv. per ongeluk alleen het land wijzigt zonder de stad te wijzigen, of dat een opmerking als "Boven de winkels" na een verhuizing in een opmerkingenveld blijft staan. Andere voorbeelden zijn RGB-kleuren, of coördinaten.

Een verbeterde versie van deze signatuur zou er bijv. zo uit zien:

[source, java]
----
public Klant processProfileForm(
        long id, 
        Persoonsgegevens persoonsgegevens,
        Contactgegevens contactgegevens,
        Adres adres
    ) throws KlantNotFoundException {
    //Implementatie laat zich raden
}
----

Een bijkomend voordeel van al deze kleine objectjes is dat ze allerhande code kunnen huisvesten (zoals het opmaken van een adres, of naam in een String) die anders erg awkward op de Klant class terecht waren gekomen. footnote:[Je zou zeker ook door kunnen gaan en een apart object kunnen aanmaken voor het hele Profile-formulier. Dan wordt de signatuur eenvoudigweg _public Klant processProfileForm(ProfileForm form)_, alleen zou dat de volgende voorbeelden wat onleesbaarder maken. Maar in de praktijk zeker geen gek idee!]

Een goed voorbeeld van zo'n standaard Value-Object dat je waarschijnlijk al tientallen keren gebruikt hebt is de DateTime class van je programmeertaal naar keuze (LocalDateTime in Java). Dat is een object dat als waarde een bepaald moment in de tijd voorstelt, en is op die manier een samenraapsel van dag/maand/jaar/tijd, en kan op allerlei verschillende manieren benaderd worden.

Als je twee van die DateTime objecten hebt, die toevallig hetzelfde moment in tijd aanwijzen, dan interesseert het je helemaal niets welke instantie je hebt, ze zijn volledig uitwisselbaar. De waarde telt.

Een tweede doel waar Value Objects zich goed voor lenen is om duidelijk aan te geven waar een object voor bedoeld is. Bijv. dat die _long_ puur een KlantId is, en niet gebruikt kan worden om een Vlucht of een Boeking op te halen.

[source, java]
----
public Klant processProfileForm(
        KlantId id, 
        Persoonsgegevens persoonsgegevens,
        Contactgegevens contactgegevens,
        Adres adres
    ) throws KlantNotFoundException {
    //Implementatie laat zich raden
}

//en elders in de codebase

public class KlantId {
    private final long value;

    public KlantId(long value){
        this.value = value;
    }

    public long getValue(){
        return this.value;
    }
}
----

Je zou nu in je KlantRepository-interface om exact deze Id-class kunnen vragen, en als je dan ooit per ongeluk het verkeerde Id zou gebruiken krijg je een nette compile error footnote:[De auto-gegenereerde Spring JPA-Repository interfaces werken helaas niet zo heel fraai met deze truc.]. 

Types (zoals Classes en Interfaces) gebruiken om compiler-errors te genereren voor 'stomme fouten' is de basis van zogeheten Type-Driven Development.

Ten derde kun je Value Objects goed gebruiken om er voor te zorgen dat iets eens en voor altijd een geldige waarde heeft. Stel je moet (zoals in <<updateKlant>>) een emailadres verwerken: er zijn meer mogelijke Strings dan dat er email-adres strings zijn. Als je emailadressen overal Strings zijn, zul je op verschillende plekken moeten gaan checken of die String eigenlijk wel een emailadres is. Bijv. bij binnenkomst van een POST (in de presentatielaag, als onderdeel van input-validatie), maar ook in de setter van een Klant (want je weet niet _zeker_ hoe je door de presentatielaag bent gekomen), en ook weer op elke plek waar je het als emailadres in de applicatie gebruikt. Bijv. in een view met een mailto: linkje, of als je geautomatiseerd een zeer-informatieve-absoluut-geen-spam-mail naar iemand wil versturen. Op die manier valideer je je een ongeluk.

Makkelijk is dan om zo gauw je weet dat het een String een emailadres zou moeten zijn om het in een Value-Object te vatten die aangeeft _dat_ het een emailadres is, en _dat_ je het _echt_ gechecked hebt:

[#emailvalueobject]
[source, java]
.Email Value-Object
----
public class EmailAddress {
    private String emailaddress;

    public EmailAddress(String rawValue){
        if(!Pattern.matches("[\\w.]+@\\w+\\.\\w+", rawValue)){ //Emailadressen zijn notoir tricky, maar dit geeft het idee
            throw new IllegalArgumentException("rawValue");
        }
        this.emailaddress = rawValue;
    }

    //getter, en misschien extra getters voor 'het stukje voor/achter de @' 
}

----

Door een <<emailvalueobject>> te gebruiken weet je op alle plekken waar je een EmailAddress instantie binnenkrijgt dat je gewoon veilig dit object kan gebruiken om een link te genereren, of een mail te versturen. Het was immers niet mogelijk om een instance te maken zonder langs je check in de constructor te komen!

Deze strategie staat ook wel bekend onder de slogan "Parse, don't Validate!" cite:[parse_dont_validate].

==== Immutability & Equals

Een goed value-object is immutable, dat betekent dat het niet gewijzigd kan worden nadat het aangemaakt is. Praktisch betekent dit dus geen setters of andere methods die interne velden wijzigen nadat het object aangemaakt is.

Een tweede essentiele eigenschap van een Value Object is dat het gaat om de waardes (what's in name...). Dat betekent dat het belangrijk is om de equals (en dus ook de hashcode) methode te overschrijven. Dat is zo'n standaard-klusje dat elke programmeertaal daar z'n eigen ritueel/standaard-implementatie voor heeft. In Java kun je dat gelukkig aan IntelliJ overlaten (of de Objects.equals / Objects.hash helper methods gebruiken).

Dit soort objecten (immutable, en puur op waarde vergelijkbaar) zijn veel simpeler te testen dan 'gewone' mutable objecten. Omdat ze niet kunnen wijzigen zijn er minder randgevallen, en is er minder testcode nodig om een goede coverage te behalen. Kortom, als je kan, is het raadzaam zoveel mogelijk van je domeinlogica op deze objecten te implementeren, dat scheelt je testcode.

Het klassieke voorbeeld cite:[evans_ddd] gaat over blikken verf (mutable) die gemengd moeten worden. Daarbij is de menglogica op kleine Color Value-Objects geïmplementeerd, wat een stuk rustiger code-design oplevert. Bij ons vliegtuig-voorbeeld zou je bijv. bij het wijzigen van een boeking de BoekingsGegevens (value-object) van de huidige boeking kunnen vergelijken met de BoekingsGegevens van de gewenste boeking, om zo een verschilfactuur te genereren, en in één keer de juiste wijziging op de opgeslagen boeking te voltooien.

Uiteindelijk heeft Immutability natuurlijk en grens en moet er namelijk wel ergens iets veranderen in een database, en dat brengt ons bij...

=== Entities

Deze kennen we! @Entity erboven, een Long'tje met @Id en @GeneratedValue en gaan met die banaan! 

Was het leven maar zo mooi...

Entities zijn objecten met een levensduur. Ze beginnen ergens, maken vanalles mee in hun bestaan, en eindigen tenslotte in een database, om het volgende request weer een nieuw rondje te maken. Wat een leven!

Entities zijn _dingen_ die over de tijd heen veranderen. Maar we hebben nog wel het gevoel dat het steeds hetzelfde _ding_ is. Bij Value-Objects hebben we dat niet. Als we een beetje rood bij geel mengen krijgen we een nieuwe kleur (iets oranje'igs). Maar als we een beetje rode verf in een blik met gele verf gieten dan verandert dat blik verf (tenzij het direct overstroomt natuurlijk), het wordt niet een nieuw blik. In dit geval kunnen we niet praten over 'het blik met die-en-die-kleur', want alles aan dat blik kan veranderen (je kan er op staan, en het indeuken bijv.). In het echt is dit geen probleem, we wijzen met onze hand naar een bepaald blik en roepen uit "Dat blik, daar heb ik het over!".

In een database heb je daarvoor een Identifier nodig. Iets dat een bepaald _ding_ uniek identificeert, zodat je er in feite naar kan _wijzen_. In onze applicatie hebben we zo'n Identifier ook nodig, want stel we vragen een bepaalde _Boeking_ op voor <<updateBoeking>>, dan willen we daar misschien een paar requests later nog een update overheen doen. Het is niet redelijk om al die boekingen in het geheugen te houden en hun exacte geheugenadres als Id te gebruiken footnote:[Nouja, misschien kan dit wel, zie bijv. <<redis>>, maar dan nog heeft persistent opslaan in een database zo z'n voordelen].

Een entity is dus een object, aangewezen door een id, met een lifecycle, wiens state kan veranderen. Met state bedoelen we alle stukjes data die bij die entity horen, alle attributen in een taal als Java, C# of Python. 

****
Niet alle combinaties van state zijn geldig voor een object. Laten we als voorbeeld de Java ArrayList nemen. Het handige van een List ten opzichte van een gewone Array is dat je er zomaar objecten aan kan toevoegen. Een Array moet je elke keer met een bepaalde grootte aanmaken. De naam suggereert dat een ArrayList de List interface biedt met een Array op de achtergrond, en als we even onder de motorkap kijkenfootnote:[rechts-click op de ArrayList class en Go-To-Definition, in IntelliJ. Echt een aanrader!]

[source, java]
----
//Fields uit de source van ArrayList.java
transient Object[] elementData; 
private int size;
----

Je ziet dat het size veld onafhankelijk wordt bijgehouden van de elementData array. Dat voelt in eerste instantie misschien een beetje stom (waarom niet gewoon elementData.length returnen in getSize()?), maar daar zit een goede reden achter.

De ArrayList class doet veel moeite om zo min mogelijk keren een nieuwe elementData array te maken. Dus als je elementen toevoegt, en er is geen ruimte meer in de array, dan maakt de ArrayList de nieuwe array 'ietsje groter dan nodig'. Op dezelfde manier laat de ArrayList met plezier wat plekjes in de array leeg als je iets removed. Het size veld moet dus los worden bijgehouden, en het zou echt _superverwarrend_ worden als het size veld niet exact klopt met hoeveel elementen er in de array zitten.

Dit is wederom het principe van OOP encapsulatie. En dat is echt essentieel voor OOP als geheel, en DDD in het bijzonder.

****

==== Repositories

==== Factories

Een Factory is een vrij standaard Design Pattern cite:[gof_design_patterns], zo heb je Abstract Factories, en Factory Methods, maar hier bedoelen we ook gewoon het simpele feit dat objecten graag elkaar maken.

Flauw gezegd is een constructor eigenlijk een heel raar ding. Op een willekeurig moment in je applicatie spreid je je armen, en roep je uit naar de hemel "Laat er een object zijn!". En, vanuit het niets, is er dan _iets_.


=== Aggregates

=== Overige Patterns


==== Domain Services

==== Domain Events

asdf

